#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ROS python api with lots of handy ROS functions
import rospy

# to be able to get the current frames and positions
import tf

# to be able to subcribe to laser scanner data
from sensor_msgs.msg import LaserScan

# to be able to publish Twist data (and move the robot)
from geometry_msgs.msg import Twist

# to be able to get the map
from nav_msgs.msg import OccupancyGrid

# to be able to do matrix multiplications
import numpy as np
from scipy import linalg


class ekf_localization(object):
    '''
    Exposes a behavior for the pioneer robot so that moves forward until
    it has an obstacle at 1.0 m then stops rotates for some time to the
    right and resumes motion.
    '''
    def __init__(self):
        '''
        Class constructor: will get executed at the moment
        of object creation
        '''
        # register node in ROS network
        rospy.init_node('ekf_localization_node', anonymous=False)
        # print message in terminal
        rospy.loginfo('ekf localization started !')
        # subscribe to pioneer laser scanner topic
        if rospy.has_param('laser_topic'):
            # retrieves the name of the LaserScan topic from the parameter server if it exists
            rospy.Subscriber(rospy.get_param('laser_topic'), LaserScan, self.laser_callback)
        else:
            rospy.Subscriber("robot_0/base_scan_1", LaserScan, self.laser_callback)
        
        # setup publisher to later on move the pioneer base
        # self.pub_cmd_vel = rospy.Publisher(rospy.get_param('robot_name')+'/cmd_vel', Twist, queue_size=1)
        # define member variable and initialize with a big value
        # it will store the distance from the robot to the walls
        self.distance = 10.0
        # create a tf listener and broadcaster instance to update tf and get positions
        self.listener = tf.TransformListener()
        self.br = tf.TransformBroadcaster()

        # starting point for the odometry
        (self.trans,self.rot) = listener.lookupTransform("odom", "base_link", rospy.Time(0))

        # defines the distance threshold below which the robot should relocalize
        if rospy.has_param('distance_threshold'):
            self.distance_threshold = rospy.get_param('distance_threshold')
        else:
            self.distance_threshold = 1.0


        # defines the angle threshold below which the robot should relocalize
        if rospy.has_param('angle_threshold'):
            self.angle_threshold = rospy.get_param('angle_threshold')
        else:
            self.angle_threshold = 0.34906585

        # iniitialize belief of where the robot is. transpose to get a column vector
        self.mu = np.transpose(np.array([0,0,0]))

         # NEED TO TWEAK THE DIAGONAL VALUES. 
        self.sigma = np.matrix([1,0,0], 
                               [0,1,0],
                               [0,0,1])

        # NEED TO TWEAK THE DIAGONAL VALUES. See presentation 3, slide 10
        self.R = np.matrix([1,0,0], 
                           [0,1,0],
                           [0,0,1])

        # NEED TO TWEAK THE DIAGONAL VALUES
        self.Q = np.matrix([1,0], 
                           [0,1])


        
    '''
    def rotate_right(self):
        #Rotate the robot by a certain angle

        # create empty message of Twist type (check http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html)
        twist_msg = Twist()
        # liner speed
        twist_msg.linear.x = 0.0
        twist_msg.linear.y = 0.0
        twist_msg.linear.z = 0.0
        # angular speed
        twist_msg.angular.x = 0.0
        twist_msg.angular.y = 0.0
        twist_msg.angular.z = -0.3

        # publish Twist message to /robot_0/cmd_vel to move the robot
        self.pub_cmd_vel.publish(twist_msg)


    def move_forward(self):

        #Move the robot forward some distance

        # create empty message of Twist type (check http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html)
        twist_msg = Twist()
        # linear speed
        twist_msg.linear.x = 0.5
        twist_msg.linear.y = 0.0
        twist_msg.linear.z = 0.0
        # angular speed
        twist_msg.angular.x = 0.0
        twist_msg.angular.y = 0.0
        twist_msg.angular.z = 0.0

        # publish Twist message to /robot_0/cmd_vel to move the robot
        self.pub_cmd_vel.publish(twist_msg)
    '''

    def laser_callback(self, msg):

        #This function gets executed everytime a laser scanner msg is received on the
        #topic: /robot_0/base_scan_1

        # ============= YOUR CODE GOES HERE! =====
        # hint: msg contains the laser scanner msg
        # hint: check http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html
        middle = len(msg.ranges)/2
        delta_angle = 0.3
        delta_index = int(delta_angle/msg.angle_increment)
        useful_ranges = msg.ranges[middle - delta_index : middle + delta_index]

        self.distance = min(useful_ranges)


        # ============= YOUR CODE ENDS HERE! =====



    #H: measurement model (maps the state we're in to the measurement we expect to see)
    #G: motion model
    #Q: model of sensor's error (covariance matrix)
    #K: Kalman gain


    # TO DO: find H and G !!!!!

    '''
    def h(x,y,theta,x_n,y_n,theta_n):
        distance = np.sqrt( (x_n - x)² + (y_n - y)² )
        angle = np.arctan( (y_n - y) / (x_n - x) ) - theta

        return (distance, angle)
    '''

    def kalman_filter():
        
        # get the odometry
        (current_trans,current_rot) = listener.lookupTransform("map", "base_link", rospy.Time(0))


        odometry_trans = current_trans - self.trans
        odometry_rot = current_rot - self.rot

        # The distance in x and y moved, and the rotation about z
        delta_odom = np.transpose(np.array([odometry_trans[0],  odometry_trans[1],  odometry_rot[2]]))

        #dont do anything if the distance traveled and angle rotated is too small
        if(np.sqrt(delta_odom[0]**2 + delta_odom[1]**2)<self.distance_threshold and delta_odom[2] < self.angle_threshold):
            return


        # delta_D_k*cos(theta_k) is the 0th element of the translation given by odometry. delta_D_k*sin(theta_k) is the 1st. 
        G = np.matrix([ [1, 0, -odometry_trans[1]], 
                        [0, 1,  odometry_trans[0]], 
                        [0, 0,        1          ] ])

        
        

        #PREDICT
        mu_predicted = self.mu + delta_odom
        sigma_predicted = np.matmul( G, np.matmul(self.sigma, np.transpose(G)) ) + self.R #NEED TO DEFINE R, COVARIANCE OF THE STATE TRANSITION NOISE

        
        # UPDATE/CORRECT
        for i in range(NUMBER_OF_OBSERVATIONS): #NEED TO DEFINE NUMBER_OF_OBSERVATIONS. This should be equal to the number of rays we make
            #NEED TO DEFINE theta_n and d_n. theta_n should be the constant angle between each ray, and d_n is the length of the current ray

            # compute a H (2*3 matrix) for every ray
            H_one_ray[i] = np.matrix([-np.cos(current_rot[2] + i*theta_n),        -np.sin(current_rot[2] + i*theta_n),        0] 
                                     [(np.sin(current_rot[2] + i*theta_n)) / d_n, -np.cos(current_rot[2] + i*theta_n) / d_n, -1])


            z_one_ray[i] = measurement_from_ros_topic_and_we_extract_one_observation #extract d_n to get the current measurement
            # can extract theta_n too, or assume it's constant and say that our current theta_n is theta_n*i, where i is iteration number
            # assuming anyways that our z_observed is on the form: [d1, theta_1, d2, theta_2, ...]^T. One long column vector


            # concatenate the current ray's observation matrix and observations so that we get a big H matrix that is 2i*3, and observation vector
            #  that is 2i*1 (two elements, d_i and theta_i added for every measurement)
            if (i == 0):
                H = H_one_ray[i]
                z = z_one_ray[i]
            else:
                H = np.concatenate(H, H_one_ray[i], axis=0)
                z = np.concatenate(z, z_one_ray[i], axis=0)


        # H is concatenated -> we need to expand Q so we get a diagonal matrix with NUMBER_OF_RAYS Q's in the diagonal so the dimensions match
        #  Q_expanded will be 2*NUMBER_OF_RAYS * 2*NUMBER_OF_RAYS since we have 2 measurements and each Q is 2*2
        Q_expanded = linalg.block_diag(* [self.Q]*NUMBER_OF_RAYS)

        # Measurement prediction covariance. Will be a 2*NUMBER_OF_RAYS * 2*NUMBER_OF_RAYS because each 
        S = np.matmul(H, np.matmul(sigma_predicted, np.transpose(H))) + Q_expanded

        # Kalman gain. Will be 3*(2*NUMBER_OF_RAYS) since every ray has "its own" Kalman gain, which is 3*2
        K = np.matmul(sigma_predicted, np.matmul(np.transpose(H), np.linalg.inv(S)))


        # expected measurements. should have same dimension as z, that is (2*NUMBER_OF_RAYS)*1
        z_expected = 

        # new_belief
        self_mu = mu_predicted + np.matmul(K, (z-z_expected))

        #new covariance
        self_sigma = sigma_predicted - np.matmul(K, np.matmul(S, np.transpose(K)))
        




    # returns the measurement we expect to see when we're in a given state
    # here we have to do the ray tracing
    def exp_measurement (state):
        
        return z_expected



    def run_behavior(self):
        while not rospy.is_shutdown():
            

            kalman_filter()

            # sleep for a small amount of time
            rospy.sleep(0.1)



def main():
    # create object of the class ekf_localization (constructor will get executed!)
    my_object = ekf_localization()
    # call run_behavior method of class EKF_localization
    my_object.run_behavior()

# if __name__ == '__main__':
#     # create object of the class EKF_localization (constructor will get executed!)
#     my_object = EKF_localization()
#     # call run_behavior method of class EKF_localization
#     my_object.run_behavior()
